#nullable enable

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using MQTTnet.Formatter;
using Sholo.Mqtt.Utilities;

namespace Sholo.Mqtt.Settings;

// ReSharper disable CommentTypo

[PublicAPI]
public class MqttSettings : IValidatableObject
{
    /// <summary>
    ///     Gets or sets the host name or IP address of the MQTT broker
    /// </summary>
    [Required]
    [MinLength(1)]
    public string Host { get; set; } = null!;

    /// <summary>
    ///     Gets or sets the username to use when connecting to the MQTT broker
    /// </summary>
    public string? Username { get; set; }

    /// <summary>
    ///     Gets or sets the password to use when connecting to the MQTT broker
    /// </summary>
    public string? Password { get; set; }

    /// <summary>
    ///     Gets or sets a value indicating whether to use TLS when connecting to the MQTT broker (default = false)
    /// </summary>
    public bool UseTls { get; set; }

    /// <summary>
    ///     Gets or sets a value indicating whether or not to ignore certificate validation errors.
    /// </summary>
    /// <remarks>
    ///     This is ignored unless <see cref="UseTls"/> is set to true.
    /// </remarks>
    public bool IgnoreCertificateValidationErorrs { get; set; }

    /// <summary>
    ///     Gets or sets the path of a PEM file containing the public key portion of the client certificate.
    /// </summary>
    /// <remarks>
    ///     This is ignored unless <see cref="UseTls"/> is set to true. This is required if <see cref="ClientCertificatePrivateKeyPemFile"/> is set.
    /// </remarks>
    public string? ClientCertificatePublicKeyPemFile { get; set; }

    /// <summary>
    ///     Gets or sets the path of a PEM file containing the private key portion of the client certificate.
    /// </summary>
    /// <remarks>
    ///     This is ignored unless <see cref="UseTls"/> is set to true. This is required if <see cref="ClientCertificatePublicKeyPemFile"/> is set.
    /// </remarks>
    public string? ClientCertificatePrivateKeyPemFile { get; set; }

    /// <summary>
    ///    Gets or sets the port of the MQTT broker (default = 1833)
    /// </summary>
    public int? Port { get; set; }

    /// <summary>
    ///     Gets or sets an MQTT client identifier to associate with the session. If not specified, a random client identifier will be generated by the broker.
    /// </summary>
    public string? ClientId { get; set; }

    /// <summary>
    ///     Gets or sets the MQTT protocol version to use when connecting to the broker: V310, V311, V500 (default = V500)
    /// </summary>
    public MqttProtocolVersion? MqttProtocolVersion { get; set; }

    /// <summary>
    ///     Gets or sets an optional message to publish when the client connects or reconnects to the broker.
    /// </summary>
    public MqttMessageSettings? OnlineMessage { get; set; } = new();

    /// <summary>
    ///     Gets or sets an optional message that the broker will automatically publish if the client disconnects without sending a DISCONNECT packet.
    /// </summary>
    public MqttMessageSettings? LastWillAndTestament { get; set; } = new();

    /// <summary>
    ///     Gets or sets the timeout which will be applied at socket level and internal operations.
    ///     The default value is the same as for sockets in .NET in general.
    /// </summary>
    public TimeSpan? Timeout { get; set; }

    /// <summary>
    ///     Gets or sets the maximum interval between MQTT control packets before the client will will automatically send a PINGREQ packet (default = 30s).
    /// </summary>
    public TimeSpan? KeepAliveInterval { get; set; }

    public virtual IEnumerable<ValidationResult> Validate(ValidationContext validationContext)
    {
        if (ClientCertificatePublicKeyPemFile == null && ClientCertificatePrivateKeyPemFile != null)
        {
            yield return new ValidationResult(
                "Client certificate public key and private key must both be specified or both be null",
                new[] { nameof(ClientCertificatePublicKeyPemFile), nameof(ClientCertificatePrivateKeyPemFile) }
            );
        }
        else if (ClientCertificatePublicKeyPemFile != null && ClientCertificatePrivateKeyPemFile == null)
        {
            yield return new ValidationResult(
                "Client certificate public key and private key must both be specified or both be null",
                new[] { nameof(ClientCertificatePublicKeyPemFile), nameof(ClientCertificatePrivateKeyPemFile) }
            );
        }

        if (OnlineMessage != null)
        {
            ValidationHelper.TryValidateObject(OnlineMessage, out var validationResults);

            foreach (var result in validationResults)
            {
                yield return new ValidationResult(result.ErrorMessage, result.MemberNames.Select(m => $"{nameof(OnlineMessage)}.{m}").ToArray());
            }
        }

        if (LastWillAndTestament != null)
        {
            ValidationHelper.TryValidateObject(LastWillAndTestament, out var validationResults);

            foreach (var result in validationResults)
            {
                yield return new ValidationResult(result.ErrorMessage, result.MemberNames.Select(m => $"{nameof(LastWillAndTestament)}.{m}").ToArray());
            }
        }
    }
}
